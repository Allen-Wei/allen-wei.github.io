
<html>
<head>
    <title>Examination</title>
    <link rel="stylesheet" href="bootstrap/css/bootstrap.css" />
</head>
<body>
    <div class="container">
        <div class="row">
            <div class="col-sm-12">

    <h2>JavaScript</h2>

    <ol>
        <li>
            <p>
                利用原型继承使得 <code>Student </code> 继承 <code>People</code> 的属性和方法. (原型继承在信销系统 <code>YsdCredit\YSD_Credit\Scripts\Services\service.Utils.js</code> 利用到.)
            </p>
            <pre>
            <code>
	function People(fn, ln){
		this.firstName = fn;
		this.lastName = ln;
		this.getFullName = function(){
			return this.firstName + " " + this.lastName;
		};
	}
	function Student(){ }
	//原型继承
	Student.prototype = new People("Alan", "Wei");
	Student.prototype.constructor = Student;
            </code>
          </pre>
        </li>

        <li>
            <p>
                关于JavaScript的<code>this</code>和闭包:
            </p>

                <pre>
            <code>
        var scope = function(){
            this.print = function(ele){
                console.info(ele);
            };
            this.iteral = function(){
                $.each(["Alan", "Allen", "Tom", "Lucy"], function(index, name){
                    //在这里如果调用 this.print 方法 ?
                });
            };
        };
            </code>
</pre>
            <p>
                这个解决方式有好几种, 描述一个简单的方式:
            </p>
<pre>
<code>
        this.iteral = function(){
            var context = this;
            $.each(...., function(index, name)({
                //在这里直接使用 this.print 是不正确的.
                context.print(name);
            });
        }
</code>
</pre>

            <p>
                其他方式参考 <a href="https://github.com/Allen-Wei/GitBlog/blob/master/JavaScript/About_Closure.md">这里</a>;
            </p>
        </li>
        <li>
            <p>
                为什么下面代码无法正确打印出名字列表? 在<code>setTimeout</code>的回调函数里如何正确地打印出名字列表?
            </p>
<pre>
            <code>
        var names = ["Alan", "Allen", "Annr"];
        for(var i = 0; i < names.length; i++){
            setTimeout(function(){
                console.log(names[i]);
            });
        }
        //利用闭包可以解决这个问题:
        var names = ["Alan", "Allen", "Annr"];
        for(var i = 0; i < names.length; i++){
            (function(name){
                setTimeout(function(){
                    console.log(name);
                });
            })(names[i]);
        }
            </code>
</pre>
        </li>
        <li>
            <p>
                利用原生JS写一个Ajax请求.
                <a href="https://developer.mozilla.org/en-US/docs/AJAX/Getting_Started">ajax</a>:
            </p>
<pre>
            <code>
        var ajax = function(method, url, contentType, data, success, fail){
            var xhr = new XMLHTTPRequest();
            xhr.oepn(method, url);
            xhr.setRequestHeader("Content-Type", "application/json");
            xhr.onreadystatechange = function(){
                if(xhr.readyState === 4 && xhr.status === 200){
                    success(xhr.responseText);
                } else {
                    fail();
                }
            };
            xhr.send(data);
        }
            </code>
</pre>

        </li>
        <li>
            <p>
                简述jQuery的Promise实现中<code>$.when</code>, <code>deferred.pipe</code>几个方法的用途, 并将上述用原生JS写的ajax方法用jQuery的Promise($.Deferred)进行封装.
            </p>
            <p>
                <code>$.when(promise1, promise2, promise3, ...)</code> when函数的每一个参数都是一个 <code>$.Deffered</code> 对象, 只有当所有的deffered都成功时, <code>$.when</code>返回的deferred对象才成功.
                <code>defered.pipe</code> jQuery的deffered对象的管道连接, 依次执行. <code>$.when</code>是并行执行, <code>deferred.pip</code> 是依次顺序执行.
            </p>
            <p>
                利用jQuery的Promise实现<code>ajax()</code>封装:
            </p>
                <pre>
            <code>
            var ajaxDeferred = function(method, url, contentType, data){
                var deferred = $.Deferred();
                ajax(method, url, contentType, data, function(data){
                    deferred.resolve(data);
                }, function(){
                    deferred.reject();
                });
                return deferred.promise();
            }
            </code>
          </pre>

        </li>
    </ol>

    <h2>C#</h2>

    <ol>
        <li>
            <p>
                如何在全局记录Web API的异常信息? 如何在全局记录Web Forms网站的异常信息?
            </p>

            <p>
                记录Web API的异常信息需要继承 <code>ExceptionFilterAttribute</code> 或者 <code>IExceptionFilter</code>. 之后需要注册全局过滤器 <code>GlobalConfiguration.Configuration.Filters.Add(...)</code>.
            </p>

            <p>
                信销系统 <code>YsdCredit\Ysd.ApplicationInterface\Library\YsdWebApiExceptionFilter.cs</code> 就是一个异常消息过滤器, <code>YsdCredit\Ysd.ApplicationInterface\App_Start\WebApiConfig.cs</code> 注册了一个全局过滤器.
            </p>

            <p>
                Web Forms网站的记录全局的异常消息需要借助 HTTP Module, 信销系统 <code>YsdCredit\Ysd.BusinessLogicLayer\Library\CommonHttpModule.cs</code> 的 <code>content_Error</code> 就注册了监听了网站的异常信息.  HTTP Module需要在 <code>web.config</code> 里配置才能生效.
            </p>

        </li>
        <li>
            <p>
                如何在网站里实现认证模块?
            </p>
            <p>
                可以监听 HTTP Module 的 <code>AuthenticateRequest</code> 事件, 修改 <code>app.Context.User</code> 来实现, 可以参考 <a href="https://github.com/Allen-Wei/Alan.Authentication.Old/blob/master/Alan.Authentication/AuthModule.cs">这里</a>. 信息系统里的认证模块就是使用这种方式.
            </p>
            <p>
                对于 MVC 和 Web API 项目可以通过继承 <code>AuthorizationFilterAttribute</code> 或者实现 <code>IAuthenticationFilter</code> 来实现.
            </p>
        </li>
    </ol>


            </div>
        </div>
    </div>


</body>
</html>
